# -*- coding: utf-8 -*-

"""Script to encode all texts in the game."""

import logging

import data


def translation_table():
    """Return a translation table combining two mappings:

       - Czech letters with diacritics mapped to chars '\xc0'..'\xdd'
       - ascii chars '\x20'..'\x7d' mapped to their value XORed by 1
    """
    translation_dict = dict(zip('ÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž',
                            map(chr, range(0xc0, 0xde))))

    translation_dict.update({chr(n): chr(n ^ 1) for n in range(0x20, 0x7e)})

    return str.maketrans(translation_dict)


def wrap_text(item, width=27):
    """Wrap input item to the width of `width` characters."""

    if '_' in item:
        for line in item.split('_'):
            yield line
        return

    while len(item) > width and ' ' in item:

        split_position = item[:width + 1].rfind(' ')

        if item[:split_position].endswith((' k', ' s', ' v', ' z')):
            split_position -= 2

        line = item[:split_position]
        item = item[split_position + 1:]

        yield line.strip()

    yield item.strip()


def main():
    # logging.basicConfig(level=logging.DEBUG, format='%(message)s')
    logging.basicConfig(level=logging.WARN, format='%(message)s')

    trans_table = translation_table()
    max_len = 128 - 4 - 3

    with open('/home/michal/dos/PUDR/PUDR/DATA.PAS', mode='w',
              encoding='latin1', newline='\r\n') as f:

        print('{generated by tools/encode_texts.py}\n', file=f)

        # generate texts
        for section in data.texts:
            section_name = next(iter(section))
            section_texts = section[section_name]

            print('{}: array[0..{}] of string[{}] = ('
                  .format(section_name, len(section_texts) - 1,
                          max(len(t) for t in section_texts)),
                  file=f)

            output = []

            for item in section_texts:
                if isinstance(item, list):
                    output_line = ''.join(chr(n + 48) for n in item)
                else:
                    wrapped = list(wrap_text(item))
                    logging.debug('{}\n{}'.format('\n'.join(wrapped), '-'*27))
                    if len(wrapped) > 6 or (section_name == 'texts_other' and len(wrapped) > 4):
                        logging.warning('TOO MANY LINES:\n{}'
                                        .format('\n'.join(wrapped)))
                    output_line = '_'.join(wrapped).translate(trans_table)

                if len(output_line) > max_len:
                    # divide to fit in Turbo Pascal IDE's max line length 128
                    output_line = output_line[:max_len] + '\'\n    + \'' + output_line[max_len:]
                    # because of this, can't use {!r} on the following line

                output.append('    \'{}\''.format(output_line))

            print(',\n'.join(output), file=f)
            print('\n);\n', file=f)

        # generate things
        thing_count = len(data.things) - 1
        print('things: array[0..{}] of thing = ('.format(thing_count), file=f)

        output = []

        for thing in data.things:
            name = thing['name'].translate(trans_table)

            img_name = thing['image'][:8]

            wrapped = list(wrap_text(thing['description']))
            logging.debug('{}\n{}'.format('\n'.join(wrapped), '-' * 27))
            if len(wrapped) > 4:
                logging.warning('TOO MANY LINES:\n{}'.format('\n'.join(wrapped)))
            desc = '_'.join(wrapped).translate(trans_table)

            output.append('  (name: \'{}\'; where: {}; portable: {}; slot: {};'
                          '\n   desc: \'{}\';\n   image: @{})'
                          .format(name, thing['where'], thing['portable'],
                                  thing['slot'], desc, img_name))

        print(',\n\n'.join(output), file=f)
        print('\n);\n', file=f)
        print('thing_count: Byte = {};'.format(thing_count), file=f)

        # report stats to stdout
        max_exit_len = max(len(item) for item in data.texts[4]['exit_names'])
        max_exit_len_items = [item
                              for item in data.texts[4]['exit_names']
                              if len(item) == max_exit_len]
        print('max. exit name length:', max_exit_len, max_exit_len_items, '', sep='\n')

        max_name_len = max(len(item['name']) for item in data.things)
        max_name_len_items = [item['name']
                              for item in data.things
                              if len(item['name']) == max_name_len]
        print('max. thing name length:', max_name_len, max_name_len_items, '', sep='\n')

        max_desc_len = max(len(item['description']) for item in data.things)
        max_desc_len_items = [item['description']
                              for item in data.things
                              if len(item['description']) == max_desc_len]
        print('max. thing description length:', max_desc_len, max_desc_len_items, '', sep='\n')


if __name__ == '__main__':
    main()
